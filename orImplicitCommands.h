!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 2024.10.19 orImplicitCommands
! Replaces the standard library's implicit actions functionality with commands
! which occur in game time.
!--------------------------------------------------------------------------------------
! Created by Jim Fisher
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
! License: Public Domain
!--------------------------------------------------------------------------------------
! First some definitions:
!
!  Commands - text the player types in, such as "wear hat".
!
!  Actions - the actions the player is trying to perform, generated by the
!     standard library by parsing player Commands, represented as variables
!     in memory, such as: action = ##wear; noun = hat;
!
!  Implicit Actions - Default behavior of the standard library, these are actions which
!     are performed automatically by the game.  The need for these is detected by the
!     standard library, such as needing to first pick up an object the character is not
!     already holding, before trying to put it on.
!
!     Depending on the verb, the standard library handles these in different ways,
!     sometimes by executing ACTUAL actions, but other times by simply moving things
!     around and changing game state instead.
!
!     Implicit actions do not advance the game turn counter.
!
!  Implicit Commands - Instead of performing implicit actions in the background, this
!     extension generates command text, representing the implied actions, and runs it
!     through the command prompt as though the player had typed it. The game's turn
!     counter is therefore incremented for each command.
!
!--------------------------------------------------------------------------------------
! Revision History
! 2024.10.19	Initial Creation
!======================================================================================
! Extension Framework management
#ifndef        orExtensionFramework_STAGE;
default        orImplicitCommands_STAGE  0;
!--------------------------------------------------------------------------------------
! INCLUDE DEPENDENCIES
#include "_orInfExt";
#include "_orHookParser";
#include "_orHookStandardLibrary";
#include "orPlayerCommandQueue";
!--------------------------------------------------------------------------------------
#ifnot;
#ifndef        orImplicitCommands_STAGE; message fatalerror orXFErrorInclude; #endif;
#iftrue(       orImplicitCommands_STAGE  < LIBRARY_STAGE);
   #undef      orImplicitCommands_STAGE  ;
   Constant    orImplicitCommands_STAGE  LIBRARY_STAGE;
   #ifdef      orImplicitCommands_STAGE  ; #endif;
   #ifndef orExtensionFrameworkBrief; message "   orImplicitCommands...";#endif;
!======================================================================================
! BEFORE PARSER
#iftrue (LIBRARY_STAGE == BEFORE_PARSER);
   replace CheckImplicitAction;
   property individual ext_generateImplicitCommands;
#endif; !--Before Parser
!======================================================================================
! AFTER VERBLIB
#iftrue (LIBRARY_STAGE == AFTER_VERBLIB);
   Constant isRootOfImplicitCommands 2; !TODO: make these first come first serve, instead of trying to manage an enum across files
   orAction _tempAction;

   !-- a simple helper used to simplify the syntax for returning a full action (n, v, s).
   [tempAction a n s;
      _tempAction.initialize(a,n,s);
      _tempAction.isMeta=false;
      return _tempAction;
   ];
   orInfExt with
      ext_suppressParsingImplicitTake[; rtrue;],   !--1. We disable the implicit take that happens during parsing.
      ext_beforeAction[tmp;                        !--2. We add a new hook, to handle implicit actions, called after parsing but before the verb routine is called
         if(no_implicit_actions==true) rfalse;

         if(action==##drop && noun notin actor) "You aren't holding ",(the)noun,".";

         tmp=LibraryExtensions.RunWhile(ext_generateImplicitCommands, false); !--check to see if we have any necessary implicit commands to handle
         if(tmp==true) rtrue;
         if(tmp~=0) return queueImplicitPrerequisite(tmp.getAction(), tmp.getNoun(), tmp.getSecond());
         rfalse;
      ],
      ext_generateImplicitCommands[;             !--3. We use the hook created above to detect and return prerequisit as actions
         if(noun==0 || util.orRef.isObject(noun)==0) rfalse;
         if(orActionFlags~=0) rfalse;
         if(action==##empty or ##transfer) rfalse;
         if(action==##puton or ##insert && second==0 or noun) rfalse;


         !--implicit take
         if(noun~= actor && noun notin actor && noun hasnt static or scenery && (not_holding~=0 || action == ##throwAt or ##wear or ##putOn or ##insert or ##give or ##show or ##wave)) { !--implicit take
            L__M(##Miscellany, 26, noun); !--first taking
            return tempAction(##take,noun);
         }
         !--implicit close
         if(action==##lock && noun has open){
            L__M(##Close, 4, noun);
            return tempAction(##close,noun);
         }

         !--implicit unlock !todo: this should be revisited: test unlock with key and confirm this still makes sense
         if(action==##open && noun has locked){
            L__M(##Unlock, 5, noun);
            if (ObjectIsUntouchable(noun, true)) return;
            return tempAction(##unlock,noun);
         }

         !--implicit disrobe
         if(noun has worn && action==##drop or ##putOn or ##insert or ##give or ##eat or ##throwAt){
            L__M(##Disrobe, 3, noun);
            return tempAction(##disrobe,noun);
         }

         !--implicit exit
         !todo

         !--implicit open
         !todo

         !--implicit close
         if(action==##lock && noun has open){
            L__M(##Close, 4, noun);
            return tempAction(##close,noun);
            !return queueImplicitPrerequisite(##Close, noun);
         }
         rfalse;
      ];

   [queueImplicitPrerequisite act n s
         tmp;
      !--loading these in the front of the queue, so do these in reverse order...
      tmp=playerCommands.preemptAction(action, noun, second);  !last: retry the current action
      tmp.setCustomFlagOn(isRootOfImplicitCommands); !TODO: not used
      tmp.setCustomFlagOn(noInferMessage);

      tmp=playerCommands.preemptAction(act,n,s);             !but first do this implicit action
      tmp.setCustomFlagOn(noInferMessage);

      meta=true;
      rtrue;
   ];


   [ CheckImplicitAction; return 2;]; !--disables most Implicit Actions in the standard library, allowing this extension to handle them instead.

#endif; !--After VERBLIB
!======================================================================================
! AFTER GRAMMAR
#iftrue (LIBRARY_STAGE == AFTER_GRAMMAR);
   !I believe this is a defect in the standard library, in that waving something should always prefer something held for waving, over something not held
   extend 'wave' first
      * held -> wave
      * held 'at' noun -> wave
   ;
#endif; !--After GRAMMAR
!======================================================================================
#endif; !--_STAGE  < LIBRARY_STAGE
#endif; !--ndef _STAGE
